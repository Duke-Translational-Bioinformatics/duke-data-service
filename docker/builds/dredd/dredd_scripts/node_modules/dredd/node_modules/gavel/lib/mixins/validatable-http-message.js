// Generated by CoffeeScript 1.9.2
var Validatable, jsonlint, mediaTyper, validators;

jsonlint = require('jsonlint');

mediaTyper = require('media-typer');

validators = require('../validators');

Validatable = (function() {
  function Validatable() {}

  Validatable.prototype.validatableComponents = ['headers', 'body', 'statusCode'];

  Validatable.prototype.validate = function() {
    var ref;
    this.validation = {};
    this.validation.version = '2';
    this.lowercaseHeaders();
    if ((this.headers != null) && (((ref = this.expected) != null ? ref.headers : void 0) != null)) {
      this.validateHeaders();
    }
    if ((this.body != null) && ((this.expected.body != null) || (this.expected.bodySchema != null))) {
      this.validateBody();
    }
    if (this.statusCode != null) {
      this.validateStatusCode();
    }
    return this.validation;
  };

  Validatable.prototype.isValidatable = function() {
    var component, i, len, ref, result;
    result = false;
    ref = this.validatableComponents;
    for (i = 0, len = ref.length; i < len; i++) {
      component = ref[i];
      if (this[component] != null) {
        result = true;
      }
    }
    return result;
  };

  Validatable.prototype.isValid = function() {
    var component, i, j, len, len1, ref, ref1, ref2, result;
    if (this.validation == null) {
      this.validate();
    }
    ref = this.validatableComponents;
    for (i = 0, len = ref.length; i < len; i++) {
      component = ref[i];
      if (Array.isArray((ref1 = this.validation[component]) != null ? ref1.results : void 0)) {
        ref2 = this.validation[component].results;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          result = ref2[j];
          if (result.severity === 'error') {
            return false;
          }
        }
      }
    }
    return true;
  };

  Validatable.prototype.validationResults = function() {
    if (this.validation == null) {
      this.validate();
    }
    return this.validation;
  };

  Validatable.prototype.lowercaseHeaders = function() {
    var expectedHeaders, headers, name, ref, ref1, ref2, value;
    if (this.headers != null) {
      headers = {};
      ref = this.headers;
      for (name in ref) {
        value = ref[name];
        headers[name.toLowerCase()] = value;
      }
      this.headers = headers;
    }
    if (((ref1 = this.expected) != null ? ref1.headers : void 0) != null) {
      expectedHeaders = {};
      ref2 = this.expected.headers;
      for (name in ref2) {
        value = ref2[name];
        expectedHeaders[name.toLowerCase()] = value;
      }
      return this.expected.headers = expectedHeaders;
    }
  };

  Validatable.prototype.validateHeaders = function() {
    this.validation.headers = {};
    this.validation.headers.results = [];
    this.setHeadersRealType();
    this.setHeadersExpectedType();
    this.setHeadersValidator();
    return this.runHeadersValidator();
  };

  Validatable.prototype.setHeadersRealType = function() {
    if (this.headers instanceof Object && !Array.isArray(this.headers)) {
      return this.validation.headers.realType = "application/vnd.apiary.http-headers+json";
    } else {
      return this.validation.headers.realType = null;
    }
  };

  Validatable.prototype.setHeadersExpectedType = function() {
    if (this.expected.headers instanceof Object && !Array.isArray(this.expected.headers)) {
      return this.validation.headers.expectedType = "application/vnd.apiary.http-headers+json";
    } else {
      return this.validation.headers.expectedType = null;
    }
  };

  Validatable.prototype.setHeadersValidator = function() {
    var base, entry, ref;
    if ((this.validation.headers.realType === (ref = this.validation.headers.expectedType) && ref === "application/vnd.apiary.http-headers+json")) {
      return this.validation.headers.validator = "HeadersJsonExample";
    } else {
      this.validation.headers.validator = null;
      if ((base = this.validation.headers).results == null) {
        base.results = [];
      }
      entry = {
        severity: 'error',
        message: "No validator found for real data media type \"" + (JSON.stringify(this.validation.headers.realType)) + "\" and expected data media type \"" + (JSON.stringify(this.validation.headers.expectedType)) + "\"."
      };
      return this.validation.headers.results.push(entry);
    }
  };

  Validatable.prototype.runHeadersValidator = function() {
    var results, validator, validatorClass;
    if (this.validation.headers.validator === null) {
      this.validation.headers.rawData = null;
    } else {
      validatorClass = validators[this.validation.headers.validator];
      validator = new validatorClass(this.headers, this.expected.headers);
      this.validation.headers.rawData = validator.validate();
    }
    if (!Array.isArray(this.validation.headers.results)) {
      this.validation.headers.results = [];
    }
    if (this.validation.headers.rawData !== null) {
      results = validator.evaluateOutputToResults();
      return this.validation.headers.results = results.concat(this.validation.headers.results);
    }
  };

  Validatable.prototype.validateBody = function() {
    this.validation.body = {};
    this.validation.body.results = [];
    this.setBodyRealType();
    this.setBodyExpectedType();
    this.setBodyValidator();
    return this.runBodyValidator();
  };

  Validatable.prototype.setBodyRealType = function() {
    var contentType, error, message, ref;
    this.validation.body.realType = null;
    if (typeof this.body !== 'string') {
      throw new Error("HTTP Body is not a String.");
    }
    contentType = (ref = this.headers) != null ? ref['content-type'] : void 0;
    if (this.isJsonContentType(contentType)) {
      try {
        jsonlint.parse(this.body);
        return this.validation.body.realType = contentType;
      } catch (_error) {
        error = _error;
        message = {
          message: 'Real body "Content-Type" header is "' + contentType + '" but body is not a parseble JSON.',
          severity: 'error'
        };
        message.message = message.message + "\n" + error.message;
        return this.validation.body.results.push(message);
      }
    } else {
      try {
        JSON.parse(this.body);
        return this.validation.body.realType = 'application/json';
      } catch (_error) {
        error = _error;
        return this.validation.body.realType = 'text/plain';
      }
    }
  };

  Validatable.prototype.setBodyExpectedType = function() {
    var base, error, expectedContentType, message, parsed, ref;
    this.validation.body.expectedType = null;
    if ((base = this.validation.body).results == null) {
      base.results = [];
    }
    if (this.expected.bodySchema != null) {
      if (typeof this.expected.bodySchema === 'string') {
        try {
          parsed = JSON.parse(this.expected.bodySchema);
          if (typeof parsed !== 'object' || Array.isArray(parsed)) {
            message = {
              message: 'Cant\'t validate. Expected body JSON Schema is not an Object',
              severity: 'error'
            };
            return this.validation.body.results.push(message);
          } else {
            return this.validation.body.expectedType = 'application/schema+json';
          }
        } catch (_error) {
          error = _error;
          message = {
            message: 'Can\'t validate. Expected body JSON Schema is not a parseable JSON',
            severity: 'error'
          };
          this.validation.body.results.push(message);
        }
      } else {
        return this.validation.body.expectedType = 'application/schema+json';
      }
    } else {
      expectedContentType = (ref = this.expected.headers) != null ? ref['content-type'] : void 0;
      if (this.isJsonContentType(expectedContentType)) {
        try {
          jsonlint.parse(this.expected.body);
          return this.validation.body.expectedType = expectedContentType;
        } catch (_error) {
          error = _error;
          message = {
            message: 'Can\'t validate. Expected body Content-Type is ' + expectedContentType + ' but body is not a parseable JSON',
            severity: 'error'
          };
          message.message = message.message + ": " + error.message;
          return this.validation.body.results.push(message);
        }
      } else {
        try {
          JSON.parse(this.expected.body);
          return this.validation.body.expectedType = 'application/json';
        } catch (_error) {
          error = _error;
          return this.validation.body.expectedType = 'text/plain';
        }
      }
    }
  };

  Validatable.prototype.setBodyValidator = function() {
    var base, errorsLength, message;
    this.validation.body.validator = null;
    if ((base = this.validation.body).results == null) {
      base.results = [];
    }
    errorsLength = this.validation.body.results.reduce(function(prev, result, index, array) {
      if (result['severity'] === 'error') {
        return prev += 1;
      }
    }, 0);
    if (errorsLength === 0) {
      if (this.isJsonContentType(this.validation.body.realType)) {
        if (this.validation.body.expectedType === 'application/schema+json') {
          return this.validation.body.validator = 'JsonSchema';
        } else if (this.isJsonContentType(this.validation.body.expectedType)) {
          return this.validation.body.validator = 'JsonExample';
        } else {
          message = {
            message: "Can't validate real media type '" + this.validation.body.realType + "' against expected media type '" + this.validation.body.expectedType + "'.",
            severity: 'error'
          };
          return this.validation.body.results.push(message);
        }
      } else if (this.validation.body.realType === 'text/plain') {
        if (this.validation.body.expectedType === 'text/plain') {
          return this.validation.body.validator = 'TextDiff';
        } else {
          message = {
            message: "Can't validate real media type '" + this.validation.body.realType + "' against expected media type '" + this.validation.body.expectedType + "'.",
            severity: 'error'
          };
          return this.validation.body.results.push(message);
        }
      } else {
        message = {
          message: "Can't validate real media type '" + this.validation.body.realType + "' against expected media type '" + this.validation.body.expectedType + "'.",
          severity: 'error'
        };
        return this.validation.body.results.push(message);
      }
    }
  };

  Validatable.prototype.runBodyValidator = function() {
    var error, expected, message, real, results, validator, validatorClass;
    if (this.validation.body.validator === null) {
      return this.validation.body.rawData = null;
    } else {
      validatorClass = validators[this.validation.body.validator];
      if (this.validation.body.validator === 'JsonSchema') {
        real = this.body;
        expected = this.expected.bodySchema;
      } else {
        real = this.body;
        expected = this.expected.body;
      }
      if (this.validation.body.validator !== null) {
        if (!Array.isArray(this.validation.body.results)) {
          this.validation.body.results = [];
        }
      }
      try {
        validator = new validatorClass(real, expected);
        this.validation.body.rawData = validator.validate();
        results = validator.evaluateOutputToResults();
        return this.validation.body.results = results.concat(this.validation.body.results);
      } catch (_error) {
        error = _error;
        message = {
          message: error.message,
          severity: 'error'
        };
        return this.validation.body.results.push(message);
      }
    }
  };

  Validatable.prototype.validateStatusCode = function() {
    var expected, real, results, validator;
    this.validation.statusCode = {};
    this.validation.statusCode.realType = "text/vnd.apiary.status-code";
    this.validation.statusCode.expectedType = "text/vnd.apiary.status-code";
    this.validation.statusCode.validator = 'TextDiff';
    real = String(this.statusCode).trim();
    expected = String(this.expected.statusCode).trim();
    validator = new validators.TextDiff(real, expected);
    this.validation.statusCode.rawData = validator.validate();
    this.validation.statusCode.results = [];
    results = validator.evaluateOutputToResults();
    this.validation.statusCode.results = results.concat(this.validation.statusCode.results);
    return this.validation.statusCode.results = this.validation.statusCode.results.map(function(current, index, arr) {
      if (current.message = 'Real and expected data does not match.') {
        current.message = "Status code is not '" + expected + "'";
      }
      return current;
    });
  };

  Validatable.prototype.isJsonContentType = function(contentType) {
    var parsed, result;
    result = false;
    if (contentType != null) {
      parsed = mediaTyper.parse("" + contentType);
      if (parsed['type'] === 'application' && parsed['subtype'] === 'json') {
        result = true;
      }
      if (parsed['suffix'] === 'json') {
        result = true;
      }
    }
    return result;
  };

  return Validatable;

})();

module.exports = {
  Validatable: Validatable
};
