// Generated by CoffeeScript 1.6.3
var parse, parseBackRequestAndResponseFromString, parseToString;

parse = function(trace) {
  var asciiHexBuffer, asciiHexSets, asciiIntBuffer, byte, code, codes, data, dataMatch, dataPattern, dir, dirMatch, dirPattern, hex, hexs, lastDir, line, output, set, stringBuffer, traceLines, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref;
  dir = function(ident) {
    if (ident === "=>") {
      return "request";
    }
    if (ident === "<=") {
      return "response";
    }
  };
  traceLines = trace.split("\n");
  dataPattern = /^(?:[a-z0-9]{4}:) ((?:[a-z0-9]{2} ){1,16})/;
  dirPattern = /^(=>|<=)/;
  asciiHexSets = [];
  lastDir = "";
  for (_i = 0, _len = traceLines.length; _i < _len; _i++) {
    line = traceLines[_i];
    dirMatch = dirPattern.exec(line);
    if (dirMatch !== null) {
      lastDir = dirMatch[0].trim();
    }
    dataMatch = dataPattern.exec(line);
    if (dataMatch !== null) {
      data = dataMatch[1].trim();
      asciiHexSets.push([lastDir, data]);
    }
  }
  asciiHexBuffer = {
    request: [],
    response: []
  };
  for (_j = 0, _len1 = asciiHexSets.length; _j < _len1; _j++) {
    set = asciiHexSets[_j];
    data = set[1];
    _ref = data.split(" ");
    for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
      byte = _ref[_k];
      asciiHexBuffer[dir(set[0])].push(byte);
    }
  }
  asciiIntBuffer = {
    request: [],
    response: []
  };
  for (dir in asciiHexBuffer) {
    hexs = asciiHexBuffer[dir];
    for (_l = 0, _len3 = hexs.length; _l < _len3; _l++) {
      hex = hexs[_l];
      asciiIntBuffer[dir].push(parseInt('0x' + hex));
    }
  }
  stringBuffer = {
    request: [],
    response: []
  };
  for (dir in asciiIntBuffer) {
    codes = asciiIntBuffer[dir];
    for (_m = 0, _len4 = codes.length; _m < _len4; _m++) {
      code = codes[_m];
      stringBuffer[dir].push(String.fromCharCode(code));
    }
  }
  output = {};
  output['request'] = stringBuffer['request'].join("");
  output['response'] = stringBuffer['response'].join("");
  return output;
};

parseToString = function(trace) {
  var line, message, output, request, requestLines, response, responseLines, _i, _j, _len, _len1;
  message = parse(trace);
  output = "";
  request = [];
  requestLines = message['request'].split("\r\n");
  for (_i = 0, _len = requestLines.length; _i < _len; _i++) {
    line = requestLines[_i];
    request.push("> " + line);
  }
  output += request.join("\r\n");
  output += "\n";
  output += "\r\n";
  response = [];
  responseLines = message['response'].split("\r\n");
  for (_j = 0, _len1 = responseLines.length; _j < _len1; _j++) {
    line = responseLines[_j];
    response.push("< " + line);
  }
  output += response.join("\r\n");
  output += "\n";
  return output;
};

parseBackRequestAndResponseFromString = function(string) {
  var line, output, request, response, stringLines, _i, _j, _len, _len1;
  output = {};
  request = [];
  stringLines = string.split('\r\n');
  for (_i = 0, _len = stringLines.length; _i < _len; _i++) {
    line = stringLines[_i];
    if (/^> /.test(line)) {
      request.push(line.replace(/^> /, ''));
    }
  }
  output['request'] = request.join('\r\n').replace(/\n$/, '');
  response = [];
  for (_j = 0, _len1 = stringLines.length; _j < _len1; _j++) {
    line = stringLines[_j];
    if (/^< /.test(line)) {
      response.push(line.replace(/^< /, ''));
    }
  }
  output['response'] = response.join('\r\n').replace(/\n$/, '');
  return output;
};

module.exports.parseBackRequestAndResponseFromString = parseBackRequestAndResponseFromString;

module.exports.parseBack = parseBackRequestAndResponseFromString;

module.exports.parseToString = parseToString;

module.exports.parse = parse;
