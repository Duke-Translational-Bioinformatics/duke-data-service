// Generated by CoffeeScript 1.9.2
var JsonSchema, SCHEMA_V3, SCHEMA_V4, ValidationErrors, amanda, clone, deepEqual, errors, jsonPointer, json_schema_options, metaSchemaV3, metaSchemaV4, sylables, tv4, type,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

amanda = require('amanda');

clone = require('clone');

deepEqual = require('deep-equal');

tv4 = require('tv4');

type = require('is-type');

jsonPointer = require('json-pointer');

metaSchemaV3 = require('../meta-schema-v3');

metaSchemaV4 = require('../meta-schema-v4');

SCHEMA_V3 = "http://json-schema.org/draft-03/schema";

SCHEMA_V4 = "http://json-schema.org/draft-04/schema";

ValidationErrors = require('./validation-errors').ValidationErrors;

errors = require('../errors');

sylables = ['a', 'e', 'i', 'o', 'u'];

json_schema_options = {
  singleError: false,
  messages: {
    'minLength': function(prop, val, validator) {
      return "The " + prop + " property must be at least " + validator + " characters long (currently " + val.length + " characters long).";
    },
    'maxLength': function(prop, val, validator) {
      return "The " + prop + " property must not exceed " + validator + " characters (currently " + val.length + " characters long).";
    },
    'length': function(prop, val, validator) {
      return "The " + prop + " property must be exactly " + validator + " characters long (currently " + val.length + " characters long).";
    },
    'format': function(prop, val, validator) {
      var ref;
      return "The " + prop + " property must be " + ((ref = validator[0].toLowerCase(), indexOf.call(sylables, ref) >= 0) ? 'an' : 'a') + " " + validator + " (current value is " + (JSON.stringify(val)) + ").";
    },
    'type': function(prop, val, validator) {
      var ref;
      return "The " + prop + " property must be " + ((ref = validator[0].toLowerCase(), indexOf.call(sylables, ref) >= 0) ? 'an' : 'a') + " " + validator + " (current value is " + (JSON.stringify(val)) + ").";
    },
    'except': function(prop, val, validator) {
      return "The " + prop + " property must not be " + val + ".";
    },
    'minimum': function(prop, val, validator) {
      return "The minimum value of the " + prop + " must be " + validator + " (current value is " + (JSON.stringify(val)) + ").";
    },
    'maximum': function(prop, val, validator) {
      return "The maximum value of the " + prop + " must be " + validator + " (current value is " + (JSON.stringify(val)) + ").";
    },
    'pattern': function(prop, val, validator) {
      return "The " + prop + " value (" + val + ") does not match the " + validator + " pattern.";
    },
    'maxItems': function(prop, val, validator) {
      return "The " + prop + " property must not contain more than " + validator + " items (currently contains " + val.length + " items).";
    },
    'minItems': function(prop, val, validator) {
      return "The " + prop + " property must contain at least " + validator + " items (currently contains " + val.length + " items).";
    },
    'divisibleBy': function(prop, val, validator) {
      return "The " + prop + " property is not divisible by " + validator + " (current value is " + (JSON.stringify(val)) + ").";
    },
    'uniqueItems': function(prop, val, validator) {
      return "All items in the " + prop + " property must be unique.";
    }
  }
};

JsonSchema = (function() {
  function JsonSchema(data1, schema) {
    var error, outError;
    this.data = data1;
    this.schema = schema;
    this.validateSchemaV4 = bind(this.validateSchemaV4, this);
    this.validatePrivate = bind(this.validatePrivate, this);
    if (type.string(this.data)) {
      try {
        this.data = JSON.parse(this.data);
      } catch (_error) {
        error = _error;
        outError = new errors.DataNotJsonParsableError('JSON validator: body: ' + error.message);
        outError['data'] = this.data;
        throw outError;
      }
    }
    if (type.string(this.schema)) {
      try {
        this.schema = JSON.parse(this.schema);
      } catch (_error) {
        error = _error;
        outError = new errors.SchemaNotJsonParsableError('JSON validator: schema: ' + error.message);
        outError['schema'] = this.schema;
        throw outError;
      }
    }
    this.jsonSchemaVersion = null;
    this.validateSchema();
  }

  JsonSchema.prototype.validateSchema = function() {
    var metaSchema, schemaValidationResult;
    if (this.schema.$schema != null) {
      if (this.schema.$schema.indexOf(SCHEMA_V3) > -1) {
        metaSchema = metaSchemaV3;
        this.jsonSchemaVersion = 'v3';
      } else if (this.schema.$schema.indexOf(SCHEMA_V4) > -1) {
        metaSchema = metaSchemaV4;
        this.jsonSchemaVersion = 'v4';
      }
    }
    if (metaSchema != null) {
      if (metaSchema.$schema) {
        tv4.reset();
        tv4.addSchema("", metaSchema);
        tv4.addSchema(metaSchema.$schema, metaSchema);
        schemaValidationResult = tv4.validateResult(this.schema, metaSchema);
        if (!(schemaValidationResult != null ? schemaValidationResult.valid : void 0)) {
          throw new errors.JsonSchemaNotValid(("JSON schema is not valid draft " + this.jsonSchemaVersion + "! ") + schemaValidationResult.error.message + ' at path "' + schemaValidationResult.error.dataPath + '"');
        }
      }
    } else {
      if (metaSchemaV3.$schema) {
        tv4.reset();
        tv4.addSchema("", metaSchemaV3);
        tv4.addSchema(metaSchemaV3.$schema, metaSchemaV3);
        schemaValidationResult = tv4.validateResult(this.schema, metaSchemaV3);
        if (schemaValidationResult != null ? schemaValidationResult.valid : void 0) {
          return this.jsonSchemaVersion = 'v3';
        }
        tv4.reset();
      }
      if (metaSchemaV4.$schema) {
        tv4.reset();
        tv4.addSchema("", metaSchemaV4);
        tv4.addSchema(metaSchemaV4.$schema, metaSchemaV4);
        schemaValidationResult = tv4.validateResult(this.schema, metaSchemaV4);
        if (schemaValidationResult != null ? schemaValidationResult.valid : void 0) {
          return this.jsonSchemaVersion = 'v4';
        }
      }
      if (this.jsonSchemaVersion === null) {
        throw new errors.JsonSchemaNotValid("JSON schema is not valid draft v3 or draft v4!");
      }
    }
  };

  JsonSchema.prototype.validate = function() {
    var dataIsTheSame, schemaIsTheSame;
    if (type.object(this.data) && this.schema['empty']) {
      this.output = {
        "length": 0,
        "errorMessages": {}
      };
      return new ValidationErrors(this.output);
    }
    dataIsTheSame = deepEqual(this.data, this._dataUsed, {
      strict: true
    });
    schemaIsTheSame = true;
    if (dataIsTheSame) {
      schemaIsTheSame = deepEqual(this.schema, this._schemaUsed, {
        strict: true
      });
    }
    if (!(dataIsTheSame && schemaIsTheSame)) {
      this.output = this.validatePrivate();
    }
    return this.output;
  };

  JsonSchema.prototype.evaluateOutputToResults = function(data) {
    var indexes, j, ref, results, results1;
    if (!data) {
      data = this.output;
    }
    if (!data) {
      return [];
    }
    results = [];
    if (data.length > 0) {
      indexes = (function() {
        results1 = [];
        for (var j = 0, ref = data.length - 1; 0 <= ref ? j <= ref : j >= ref; 0 <= ref ? j++ : j--){ results1.push(j); }
        return results1;
      }).apply(this);
      indexes.forEach(function(index) {
        var item, message, pathArray, ref1;
        item = data[index];
        if (item['property'] == null) {
          pathArray = [];
        } else if (Array.isArray(item['property']) && item['property'].length === 1 && ((ref1 = item['property'][0]) === null || ref1 === (void 0))) {
          pathArray = [];
        } else {
          pathArray = item['property'];
        }
        message = {
          pointer: jsonPointer.compile(pathArray),
          severity: 'error',
          message: item.message
        };
        return results.push(message);
      });
    }
    return results;
  };

  JsonSchema.prototype.validatePrivate = function() {
    this._dataUsed = this.data;
    this._schemaUsed = this.schema;
    if (this.jsonSchemaVersion === 'v3') {
      return this.validateSchemaV3();
    } else if (this.jsonSchemaVersion === 'v4') {
      return this.validateSchemaV4();
    } else {
      throw new Error("JSON schema version not identified, can't validate!");
    }
  };

  JsonSchema.prototype.validateSchemaV4 = function() {
    var amandaCompatibleError, error, index, j, len, pathArray, pointer, ref, result;
    result = tv4.validateMultiple(this.data, this.schema);
    amandaCompatibleError = {
      length: result.errors.length,
      errorMessages: {}
    };
    ref = result != null ? result.errors : void 0;
    for (index = j = 0, len = ref.length; j < len; index = ++j) {
      error = ref[index];
      pathArray = jsonPointer.parse(error.dataPath);
      if (error.params.key) {
        pathArray.push(error.params.key);
      }
      pointer = jsonPointer.compile(pathArray);
      amandaCompatibleError[index] = {
        "property": pathArray,
        "attributeValue": true,
        "message": "At '" + pointer + "' " + error.message,
        "validatorName": "error"
      };
    }
    return this.errors = new ValidationErrors(amandaCompatibleError);
  };

  JsonSchema.prototype.validateSchemaV3 = function() {
    var err, error;
    try {
      return amanda.validate(this.data, this.schema, json_schema_options, (function(_this) {
        return function(error) {
          var i, j, ref;
          if ((error != null ? error.length : void 0) > 0) {
            for (i = j = 0, ref = error.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
              if (error[i].property === '') {
                error[i].property = [];
              }
            }
          }
          return _this.errors = new ValidationErrors(error);
        };
      })(this));
    } catch (_error) {
      error = _error;
      err = {
        "0": {
          "property": [],
          "attributeValue": true,
          "message": "Validator internal error: " + error.message,
          "validatorName": "error"
        },
        "length": 1,
        "errorMessages": {}
      };
      this.errors = new ValidationErrors(err);
      return this.errors;
    }
  };

  return JsonSchema;

})();

module.exports = {
  JsonSchema: JsonSchema
};
