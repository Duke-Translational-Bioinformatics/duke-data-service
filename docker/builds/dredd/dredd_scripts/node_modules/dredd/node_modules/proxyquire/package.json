{
  "name": "proxyquire",
  "version": "1.7.10",
  "description": "Proxies nodejs require in order to allow overriding dependencies during testing.",
  "main": "index.js",
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/thlorenz/proxyquire.git"
  },
  "keywords": [
    "require",
    "dependency",
    "injection",
    "di",
    "inject",
    "swap",
    "test",
    "mock",
    "stub"
  ],
  "author": {
    "name": "Thorsten Lorenz"
  },
  "license": "MIT",
  "devDependencies": {
    "mocha": "~1.18",
    "should": "~3.3",
    "sinon": "~1.9"
  },
  "dependencies": {
    "fill-keys": "^1.0.2",
    "module-not-found-error": "^1.0.0",
    "resolve": "~1.1.7"
  },
  "readme": "# proxyquire [![Build Status](https://secure.travis-ci.org/thlorenz/proxyquire.svg)](http://travis-ci.org/thlorenz/proxyquire)\n\n[![NPM](https://nodei.co/npm/proxyquire.png?downloads=true&stars=true)](https://nodei.co/npm/proxyquire/)\n\nProxies nodejs's require in order to make overriding dependencies during testing easy while staying **totally unobstrusive**.\n\nIf you want to stub dependencies for your client side modules, try\n[proxyquireify](https://github.com/thlorenz/proxyquireify), a proxyquire for [browserify\nv2](https://github.com/substack/browserify) or [proxyquire-universal](https://github.com/bendrucker/proxyquire-universal) \nto test in both Node and the browser.\n\n# Features\n\n- **no changes to your code** are necessary\n- non overridden methods of a module behave like the original\n- mocking framework agnostic, if it can stub a function then it works with proxyquire\n- \"use strict\" compliant\n\n# Example\n\n**foo.js:**\n\n```javascript\nvar path = require('path');\n\nmodule.exports.extnameAllCaps = function (file) {\n  return path.extname(file).toUpperCase();\n};\n\nmodule.exports.basenameAllCaps = function (file) {\n  return path.basename(file).toUpperCase();\n};\n```\n\n**foo.test.js:**\n\n```javascript\nvar proxyquire =  require('proxyquire')\n  , assert     =  require('assert')\n  , pathStub   =  { };\n\n// when no overrides are specified, path.extname behaves normally\nvar foo = proxyquire('./foo', { 'path': pathStub });\nassert.equal(foo.extnameAllCaps('file.txt'), '.TXT');\n\n// override path.extname\npathStub.extname = function (file) { return 'Exterminate, exterminate the ' + file; };\n\n// path.extname now behaves as we told it to\nassert.equal(foo.extnameAllCaps('file.txt'), 'EXTERMINATE, EXTERMINATE THE FILE.TXT');\n\n// path.basename and all other path module methods still function as before\nassert.equal(foo.basenameAllCaps('/a/b/file.txt'), 'FILE.TXT');\n```\n\nYou can also replace functions directly:\n\n```js\nvar get    = require('simple-get');\nvar assert = require('assert');\n\nmodule.exports = function fetch (callback) {\n  get('https://api/users', callback);\n};\n```\n\n```js\nvar proxyquire = require('proxyquire');\nvar fetch = proxyquire('./get', {\n  'simple-get': function (url, callback) {\n    process.nextTick(function () {\n      callback(null, fakeResponse)\n    })\n  }\n});\n\nfetch(function (err, res) {\n  assert(res.statusCode, 200)\n});\n```\n\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*\n\n- [Usage](#usage)\n- [API](#api)\n  - [Preventing call thru to original dependency](#preventing-call-thru-to-original-dependency)\n    - [Prevent call thru for all future stubs resolved by a proxyquire instance](#prevent-call-thru-for-all-future-stubs-resolved-by-a-proxyquire-instance)\n    - [Re-enable call thru for all future stubs resolved by a proxyquire instance](#re-enable-call-thru-for-all-future-stubs-resolved-by-a-proxyquire-instance)\n      - [All together, now](#all-together-now)\n  - [Using proxyquire to simulate the absence of Modules](#using-proxyquire-to-simulate-the-absence-of-modules)\n  - [Forcing proxyquire to reload modules](#forcing-proxyquire-to-reload-modules)\n  - [Globally override require](#globally-override-require)\n    - [Caveat](#caveat)\n    - [Globally override require during module initialization](#globally-override-require-during-module-initialization)\n    - [Why is proxyquire messing with my `require` cache?](#why-is-proxyquire-messing-with-my-require-cache)\n    - [Globally override require during module runtime](#globally-override-require-during-module-runtime)\n  - [Configuring proxyquire by setting stub properties](#configuring-proxyquire-by-setting-stub-properties)\n- [Backwards Compatibility for proxyquire v0.3.x](#backwards-compatibility-for-proxyquire-v03x)\n- [Examples](#examples)\n- [More Examples](#more-examples)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n\n# Usage\n\nTwo simple steps to override require in your tests:\n\n- add `var proxyquire = require('proxyquire');` to top level of your test file\n- `proxyquire(...)` the module you want to test and pass along stubs for modules you want to override\n\n# API\n\n***proxyquire({string} request, {Object} stubs)***\n\n- **request**: path to the module to be tested e.g., `../lib/foo`\n- **stubs**: key/value pairs of the form `{ modulePath: stub, ... }`\n    - module paths are relative to the tested module **not** the test file\n    - therefore specify it exactly as in the require statement inside the tested file\n    - values themselves are key/value pairs of functions/properties and the appropriate override\n\n## Preventing call thru to original dependency\n\nBy default proxyquire calls the function defined on the *original* dependency whenever it is not found on the stub.\n\nIf you prefer a more strict behavior you can prevent *callThru* on a per module or contextual basis.\n\nIf *callThru* is disabled, you can stub out modules that don't even exist on the machine that your tests are running on.\nWhile I wouldn't recommend this in general, I have seen cases where it is legitimately useful (e.g., when requiring\nglobal environment configs in json format that may not be available on all machines).\n\n**Prevent call thru on path stub:**\n\n```javascript\nvar foo = proxyquire('./foo', {\n  path: {\n      extname: function (file) { ... }\n    , '@noCallThru': true\n  }\n});\n```\n\n### Prevent call thru for all future stubs resolved by a proxyquire instance\n\n```javascript\n// all stubs resolved by proxyquireStrict will not call through by default\nvar proxyquireStrict = require('proxyquire').noCallThru();\n\n// all stubs resolved by proxyquireNonStrict will call through by default\nvar proxyquireNonStrict = require('proxyquire');\n```\n\n### Re-enable call thru for all future stubs resolved by a proxyquire instance\n\n```javascript\nproxyquire.callThru();\n```\n\n**Call thru configurations per module override `callThru()`:**\n\nPassing `@noCallThru: false` when configuring modules will override `noCallThru()`:\n\n```javascript\nvar foo = proxyquire\n    .noCallThru()\n    .load('./foo', {\n\n        // no calls to original './bar' methods will be made\n        './bar' : { toAtm: function (val) { ... } }\n\n        // for 'path' module they will be made\n      , path: {\n          extname: function (file) { ... }\n        , '@noCallThru': false\n        }\n    });\n```\n\n#### All together, now\n\n```javascript\nvar proxyquire = require('proxyquire').noCallThru();\n\n// all methods for foo's dependencies will have to be stubbed out since proxyquire will not call through\nvar foo = proxyquire('./foo', stubs);\n\nproxyquire.callThru();\n\n// only some methods for foo's dependencies will have to be stubbed out here since proxyquire will now call through\nvar foo2 = proxyquire('./foo', stubs);\n```\n\n## Using proxyquire to simulate the absence of Modules\n\nSome libraries may behave differently in the presence or absence of a\npackage, for example:\n\n```javascript\nvar cluster;\ntry {\n  cluster = require('cluster');\n} catch(e) {\n  // cluster module is not present.\n  cluster = null\n}\nif (cluster) {\n  // Then provide some functionality for a cluster-aware version of Node.js\n} else {\n  // and some alternative for a cluster-unaware version.\n}\n```\n\nTo exercise the second branch of the `if` statement, you can make proxyquire pretend the package isn't present by\nsetting the stub for it to `null`. This works even if a `cluster` module is actually present.\n\n```javascript\nvar foo = proxyquire('./foo', { cluster: null });\n```\n\n## Forcing proxyquire to reload modules\n\nIn most situations it is fine to have proxyquire behave exactly like nodejs `require`, i.e. modules that are loaded once\nget pulled from the cache the next time.\n\nFor some tests however you need to ensure that the module gets loaded fresh everytime, i.e. if that causes initializing\nsome dependency or some module state.\n\nFor this purpose proxyquire exposes the `noPreserveCache` function.\n\n```js\n// ensure we don't get any module from the cache, but to load it fresh every time\nvar proxyquire = require('proxyquire').noPreserveCache();\n\nvar foo1 = proxyquire('./foo', stubs);\nvar foo2 = proxyquire('./foo', stubs);\nvar foo3 = require('./foo');\n\n// foo1, foo2 and foo3 are different instances of the same module\nassert.notEqual(foo1, foo2);\nassert.notEqual(foo1, foo3);\n```\n\n`require.preserveCache` allows you to restore the behavior to match nodejs's `require` again.\n\n```js\nproxyquire.preserveCache();\n\nvar foo1 = proxyquire('./foo', stubs);\nvar foo2 = proxyquire('./foo', stubs);\nvar foo3 = require('./foo');\n\n// foo1, foo2 and foo3 are the same instance\nassert.equal(foo1, foo2);\nassert.equal(foo1, foo3);\n```\n\n\n## Globally override require\n\nUse the `@global` property to override every `require` of a module, even transitively.\n\n### Caveat\n\nYou should **think very hard about alternatives before using this feature**. Why, because it's intrusive and as you'll\nsee if you read on it changes the default behavior of module initialization which means that code runs differently\nduring testing than it does normally.\n\nAdditionally it **makes it harder to reason about how your tests work**. \n\n> Yeah, we are mocking `fs` three levels down in `bar`, so that's why we have to set it up when testing `foo`\n\n**WAAAT???**\n\nIf you write proper unit tests you should never have a need for this. So here are some techniques to consider:\n\n- test each module in isolation\n- make sure your modules are small enough and do only one thing\n- stub out dependencies directly instead of stubbing something inside your dependencies\n- if you are testing `bar` and `bar` calls `foo.read` and `foo.read` calls `fs.readFile` proceed as follows\n  - **do not** stub out `fs.readFile` globally\n  - instead stub out `foo` so you can control what `foo.read` returns without ever even hitting `fs`\n\nOK, made it past the warnings and still feel like you need this? Read on then but you are on your own now, this is as\nfar as I'll go ;)\n\nWatch out for more warnings below.\n\n### Globally override require during module initialization\n\n```javascript\n// foo.js\nvar bar = require('bar');\n\nmodule.exports = function() {\n  bar();\n}\n\n// bar.js\nvar baz = require('baz');\n\nmodule.exports = function() {\n  baz.method();\n}\n\n// baz.js\nmodule.exports = {\n  method: function() {\n    console.info('hello');\n  }\n}\n\n// test.js\nvar stubs = {\n  'baz': {\n    method: function(val) {\n      console.info('goodbye');\n    },\n    '@global': true\n  }\n};\n\nvar proxyquire = require('proxyquire');\n\nvar foo = proxyquire('foo', stubs);\nfoo();  // 'goodbye' is printed to stdout\n```\n\nBe aware that when using global overrides **any module initialization code will be re-executed for each require.**\n\nThis is not normally the case since node.js caches the return value of `require`, however to make global overrides work ,\n`proxyquire` bypasses the module cache. This may cause **unexpected behaviour if a module's initialization causes side effects**.\n\nAs an example consider this module which opens a file during its initialization:\n\n```javascript\nvar fs = require('fs')\n  , C = require('C');\n\n// will get executed twice\nvar file = fs.openSync('/tmp/foo.txt', 'w');\n\nmodule.exports = function() {\n  return new C(file);\n};\n```\n\nThe file at `/tmp/foo.txt` could be created and/or truncated more than once.\n\n### Why is proxyquire messing with my `require` cache?\n\nSay you have a module, C, that you wish to stub.  You require module A which contains `require('B')`. Module B in turn\ncontains `require('C')`. If module B has already been required elsewhere then when module A receives the cached version\nof module B and proxyquire would have no opportunity to inject the stub for C.\n\nTherefore when using the `@global` flag, `proxyquire` will bypass the `require` cache.\n\n### Globally override require during module runtime\n\nSay you have a module that looks like this:\n\n```javascript\nmodule.exports = function() {\n  var d = require('d');\n  d.method();\n};\n```\nThe invocation of `require('d')` will happen at runtime and not when the containing module is requested via `require`.\nIf you want to globally override `d` above, use the `@runtimeGlobal` property:\n\n```javascript\nvar stubs = {\n  'd': {\n    method: function(val) {\n      console.info('hello world');\n    },\n    '@runtimeGlobal': true\n  }\n};\n```\n\nThis will cause module setup code to be re-excuted just like `@global`, but with the difference that it will happen\nevery time the module is requested via `require` at runtime as no module will ever be cached.\n\nThis can cause subtle bugs so if you can guarantee that your modules will not vary their `require` behaviour at runtime,\nuse `@global` instead.\n\n## Configuring proxyquire by setting stub properties\n\nEven if you want to override a module that exports a function directly, you can still set special properties like `@global`. You can use a named function or assign your stub function to a variable to add properties:\n\n```js\nfoo['@global'] = true;\nfunction foo () {}\nproxyquire('./bar', {\n  foo: foo\n});\n```\n\nAnd if your stub is in a separate module where `module.exports = foo`:\n\n```js\nvar foostub = require('../stubs/foostub');\nfoostub['@global'] = true;\nproxyquire('bar', {\n  foo: foostub\n});\n```\n\n# Backwards Compatibility for proxyquire v0.3.x\n\nCompatibility mode with proxyquire v0.3.x **has been removed**.\n\nYou should update your code to use the newer API but if you can't, pin the version of proxyquire in your package.json file to ~0.6 in order to continue using the older style.\n\n# Examples\n\n**We are testing foo which depends on bar:**\n\n```javascript\n// bar.js module\nmodule.exports = {\n    toAtm: function (val) { return  0.986923267 * val; }\n};\n\n// foo.js module\n// requires bar which we will stub out in tests\nvar bar = require('./bar');\n[ ... ]\n\n```\n\n**Tests:**\n\n```javascript\n// foo-test.js module which is one folder below foo.js (e.g., in ./tests/)\n\n/*\n *   Option a) Resolve and override in one step:\n */\nvar foo = proxyquire('../foo', {\n  './bar': { toAtm: function (val) { return 0; /* wonder what happens now */ } }\n});\n\n// [ .. run some tests .. ]\n\n/*\n *   Option b) Resolve with empty stub and add overrides later\n */\nvar barStub = { };\n\nvar foo =  proxyquire('../foo', { './bar': barStub });\n\n// Add override\nbarStub.toAtm = function (val) { return 0; /* wonder what happens now */ };\n\n[ .. run some tests .. ]\n\n// Change override\nbarStub.toAtm = function (val) { return -1 * val; /* or now */ };\n\n[ .. run some tests .. ]\n\n// Resolve foo and override multiple of its dependencies in one step - oh my!\nvar foo = proxyquire('./foo', {\n    './bar' : {\n      toAtm: function (val) { return 0; /* wonder what happens now */ }\n    }\n  , path    : {\n      extname: function (file) { return 'exterminate the name of ' + file; }\n    }\n});\n```\n\n# More Examples\n\nFor more examples look inside the [examples folder](https://github.com/thlorenz/proxyquire/tree/master/examples/) or\nlook through the [tests](https://github.com/thlorenz/proxyquire/blob/master/test/proxyquire.js)\n\n**Specific Examples:**\n\n- test async APIs synchronously: [examples/async](https://github.com/thlorenz/proxyquire/tree/master/examples/async).\n- using proxyquire with [Sinon.JS](http://sinonjs.org/): [examples/sinon](https://github.com/thlorenz/proxyquire/tree/master/examples/sinon).\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/thlorenz/proxyquire/issues"
  },
  "_id": "proxyquire@1.7.10",
  "_from": "proxyquire@~1.7.x"
}
