var EventEmitter, Pitboss, Runner, csv, exec, fork, os, path, pusage, ref,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

path = require('path');

ref = require('child_process'), fork = ref.fork, exec = ref.exec;

EventEmitter = require('events').EventEmitter;

pusage = require('pidusage');

os = require('os');

csv = require('csv');

exports.Pitboss = Pitboss = (function() {
  function Pitboss(code, options) {
    this.runner = new Runner(code, options);
    this.queue = [];
    this.runner.on('completed', this.next.bind(this));
  }

  Pitboss.prototype.run = function(arg1, callback) {
    var context, libraries;
    context = arg1.context, libraries = arg1.libraries;
    this.queue.push({
      context: context,
      libraries: libraries,
      callback: callback
    });
    this.next();
  };

  Pitboss.prototype.kill = function() {
    var ref1;
    return (ref1 = this.runner) != null ? ref1.kill(1) : void 0;
  };

  Pitboss.prototype.next = function() {
    var c;
    if (this.runner.running) {
      return false;
    }
    c = this.queue.shift();
    if (c) {
      this.runner.run({
        context: c.context,
        libraries: c.libraries
      }, c.callback);
    }
  };

  return Pitboss;

})();

exports.Runner = Runner = (function(superClass) {
  extend(Runner, superClass);

  function Runner(code1, options1) {
    var base, base1, base2;
    this.code = code1;
    this.options = options1;
    this.winMemory = bind(this.winMemory, this);
    this.notifyCompleted = bind(this.notifyCompleted, this);
    this.memoryExceeded = bind(this.memoryExceeded, this);
    this.timeout = bind(this.timeout, this);
    this.failedForkHandler = bind(this.failedForkHandler, this);
    this.messageHandler = bind(this.messageHandler, this);
    this.disconnect = bind(this.disconnect, this);
    this.run = bind(this.run, this);
    this.options || (this.options = {});
    (base = this.options).memoryLimit || (base.memoryLimit = 64 * 1024);
    (base1 = this.options).timeout || (base1.timeout = 500);
    (base2 = this.options).heartBeatTick || (base2.heartBeatTick = 100);
    this.callback = null;
    this.running = false;
    this.launchFork();
    Runner.__super__.constructor.call(this);
  }

  Runner.prototype.launchFork = function() {
    var base, base1;
    if (this.proc) {
      if (typeof (base = this.proc).removeAllListeners === "function") {
        base.removeAllListeners('exit');
      }
      if (typeof (base1 = this.proc).removeAllListeners === "function") {
        base1.removeAllListeners('message');
      }
      if (this.proc.connected) {
        this.proc.kill('SIGTERM');
      }
    }
    this.proc = fork(path.join(__dirname, '../lib/forkable.js'));
    this.proc.on('message', this.messageHandler);
    this.proc.on('exit', this.failedForkHandler);
    this.proc.send({
      code: this.code,
      timeout: this.options.timeout + 100
    });
  };

  Runner.prototype.run = function(arg1, callback) {
    var context, id, libraries, msg;
    context = arg1.context, libraries = arg1.libraries;
    if (this.running) {
      return false;
    }
    id = Date.now().toString() + Math.floor(Math.random() * 1000);
    msg = {
      context: context,
      libraries: libraries,
      id: id
    };
    this.callback = callback || false;
    this.startTimer();
    this.running = id;
    this.proc.send(msg);
    return id;
  };

  Runner.prototype.disconnect = function() {
    if (this.proc && this.proc.connected) {
      this.proc.disconnect();
    }
  };

  Runner.prototype.kill = function(dieWithoutRestart) {
    if (this.proc && this.proc.connected) {
      if (dieWithoutRestart) {
        this.proc.removeAllListeners('exit');
        this.proc.removeAllListeners('message');
      }
      this.proc.kill("SIGTERM");
    }
    this.closeTimer();
  };

  Runner.prototype.messageHandler = function(msg) {
    var cb;
    this.running = false;
    this.closeTimer();
    this.emit('result', msg);
    if (this.callback) {
      cb = this.callback;
      this.callback = false;
      if (msg.error) {
        cb(msg.error);
      } else {
        cb(null, msg.result);
      }
    }
    this.notifyCompleted();
  };

  Runner.prototype.failedForkHandler = function() {
    var error;
    this.running = false;
    this.closeTimer(this.timer);
    this.launchFork();
    error = this.currentError || "Process Failed";
    this.emit('failed', error);
    if (this.callback) {
      this.callback(error);
    }
    this.notifyCompleted();
  };

  Runner.prototype.timeout = function() {
    if (this.currentError == null) {
      this.currentError = "Timedout";
    }
    this.kill();
  };

  Runner.prototype.memoryExceeded = function() {
    var pid, ref1, ref2;
    if (!((ref1 = this.proc) != null ? ref1.pid : void 0)) {
      return;
    }
    pid = this.proc.pid;
    if ((ref2 = os.platform()) === 'win' || ref2 === 'win32' || ref2 === 'win64') {
      return this.winMemory(pid, (function(_this) {
        return function(err, stats) {
          var ref3;
          if (stats == null) {
            stats = [];
          }
          if (err) {
            if (_this.running) {
              console.error("Process memory usage command failed", err);
            }
          }
          if (!err && ((stats != null ? (ref3 = stats[0]) != null ? ref3.memUsage : void 0 : void 0) || 0) > _this.options.memoryLimit) {
            _this.currentError = "MemoryExceeded";
            _this.kill();
          }
        };
      })(this));
    }
    pusage.stat(pid, (function(_this) {
      return function(err, stat) {
        if (stat == null) {
          stat = {};
        }
        if (err) {
          if (_this.running) {
            console.error("Process memory usage command failed", err);
          }
        }
        pusage.unmonitor(pid);
        if ((!err) && stat.memory > (_this.options.memoryLimit * 1024)) {
          _this.currentError = "MemoryExceeded";
          _this.kill();
        }
      };
    })(this));
  };

  Runner.prototype.notifyCompleted = function() {
    this.running = false;
    this.emit('completed');
  };

  Runner.prototype.startTimer = function() {
    this.closeTimer();
    this.timer = setTimeout(this.timeout, this.options['timeout']);
    this.memoryTimer = setInterval(this.memoryExceeded, this.options['heartBeatTick']);
  };

  Runner.prototype.closeTimer = function() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
    if (this.memoryTimer) {
      clearInterval(this.memoryTimer);
      this.memoryTimer = null;
    }
  };

  Runner.prototype.winMemory = function(pid, cb) {
    var procStat, taskList, taskListPath;
    taskListPath = 'tasklist.exe ';
    taskList = function(arg, taskListCallback) {
      exec(taskListPath + arg, function(err, stdout) {
        taskListCallback(err, stdout);
      });
    };
    procStat = function(procStatCallback) {
      var arg, stats, type;
      type = 'PID';
      arg = "/fi \"PID eq " + pid + "\" /fo CSV";
      stats = [];
      taskList(arg, function(err, stdout) {
        if (stdout == null) {
          stdout = '';
        }
        if (err || !stdout) {
          return;
        }
        csv.parse(stdout, function(err, rows) {
          var i, len, memVal, row;
          if (err) {
            return procStatCallback(err, stats);
          }
          if ((rows != null ? rows.length : void 0) > 0) {
            for (i = 0, len = rows.length; i < len; i++) {
              row = rows[i];
              if (!(parseInt(row[1], 10) === pid)) {
                continue;
              }
              if (row[4]) {
                memVal = ("" + (row[4] || '')).toLowerCase().replace(',', '.').trim();
                if (memVal.indexOf('k')) {
                  memVal = 1000 * parseInt(memVal.slice(0, -1));
                } else if (memVal.indexOf('m')) {
                  memVal = 1000 * 1000 * parseInt(memVal.slice(0, -1), 10);
                } else {
                  memVal = 1000 * parseFloat(memVal.slice(0, -1));
                }
              } else {
                memVal = parseFloat(row[4]);
              }
              stats.push({
                name: row[0],
                pid: pid,
                memUsage: memVal
              });
            }
            procStatCallback(err, stats);
          } else {
            procStatCallback(err, stats);
          }
        });
      });
    };
    procStat(cb);
  };

  return Runner;

})(EventEmitter);
