// Generated by CoffeeScript 1.10.0
var EventEmitter, HooksWorkerClient, child_process, generateUuid, logger, net, which,
  hasProp = {}.hasOwnProperty;

net = require('net');

EventEmitter = require('events').EventEmitter;

child_process = require('child_process');

generateUuid = require('node-uuid').v4;

logger = require('./logger');

which = require('./which');

HooksWorkerClient = (function() {
  function HooksWorkerClient(runner) {
    var options;
    this.runner = runner;
    options = this.runner.hooks.configuration.options;
    this.language = options.language;
    this.timeout = options['hooks-worker-timeout'] || 5000;
    this.connectTimeout = options['hooks-worker-connect-timeout'] || 1500;
    this.connectRetry = options['hooks-worker-connect-retry'] || 500;
    this.afterConnectWait = options['hooks-worker-after-connect-wait'] || 100;
    this.termTimeout = options['hooks-worker-term-timeout'] || 5000;
    this.termRetry = options['hooks-worker-term-retry'] || 500;
    this.handlerHost = options['hooks-worker-handler-host'] || 'localhost';
    this.handlerPort = options['hooks-worker-handler-port'] || 61321;
    this.handlerMessageDelimiter = '\n';
    this.clientConnected = false;
    this.handlerEnded = false;
    this.handlerKilledIntentionally = false;
    this.connectError = false;
    this.emitter = new EventEmitter;
  }

  HooksWorkerClient.prototype.start = function(callback) {
    return this.setCommandAndCheckForExecutables((function(_this) {
      return function(executablesError) {
        if (executablesError) {
          return callback(executablesError);
        }
        return _this.spawnHandler(function(spawnHandlerError) {
          if (spawnHandlerError) {
            return callback(spawnHandlerError);
          }
          return _this.connectToHandler(function(connectHandlerError) {
            if (connectHandlerError) {
              return callback(connectHandlerError);
            }
            return _this.registerHooks(function(registerHooksError) {
              if (registerHooksError) {
                return callback(registerHooksError);
              }
              return callback();
            });
          });
        });
      };
    })(this));
  };

  HooksWorkerClient.prototype.stop = function(callback) {
    this.disconnectFromHandler();
    return this.terminateHandler(callback);
  };

  HooksWorkerClient.prototype.terminateHandler = function(callback) {
    var kill, start, term, timeout, waitForHandlerTermOrKill;
    term = (function(_this) {
      return function() {
        logger.info('Sending SIGTERM to the hooks handler');
        _this.handlerKilledIntentionally = true;
        return _this.handler.kill('SIGTERM');
      };
    })(this);
    kill = (function(_this) {
      return function() {
        logger.info('Killing hooks handler');
        return _this.handler.kill('SIGKILL');
      };
    })(this);
    start = Date.now();
    term();
    waitForHandlerTermOrKill = (function(_this) {
      return function() {
        var timeout;
        if (_this.handlerEnded === true) {
          clearTimeout(timeout);
          return callback();
        } else {
          if ((Date.now() - start) < _this.termTimeout) {
            term();
            return timeout = setTimeout(waitForHandlerTermOrKill, _this.termRetry);
          } else {
            kill();
            clearTimeout(timeout);
            return callback();
          }
        }
      };
    })(this);
    return timeout = setTimeout(waitForHandlerTermOrKill, this.termRetry);
  };

  HooksWorkerClient.prototype.disconnectFromHandler = function() {
    return this.handlerClient.destroy();
  };

  HooksWorkerClient.prototype.setCommandAndCheckForExecutables = function(callback) {
    var error, msg;
    if (this.language === 'ruby') {
      this.handlerCommand = 'dredd-hooks-ruby';
      if (!which.which(this.handlerCommand)) {
        msg = " Ruby hooks handler server command not found: " + this.handlerCommand + "\nInstall ruby hooks handler by running:\n$ gem install dredd_hooks";
        error = new Error(msg);
        return callback(error);
      } else {
        return callback();
      }
    } else if (this.language === 'python') {
      this.handlerCommand = 'dredd-hooks-python';
      if (!which.which(this.handlerCommand)) {
        msg = " Python hooks handler server command not found: " + this.handlerCommand + "\nInstall python hooks handler by running:\n$ pip install dredd_hooks";
        error = new Error(msg);
        return callback(error);
      } else {
        return callback();
      }
    } else if (this.language === 'php') {
      this.handlerCommand = 'dredd-hooks-php';
      if (!which.which(this.handlerCommand)) {
        msg = " PHP hooks handler server command not found: " + this.handlerCommand + "\nInstall php hooks handler by running:\n$ composer require ddelnano/dredd-hooks-php --dev";
        error = new Error(msg);
        return callback(error);
      } else {
        return callback();
      }
    } else if (this.language === 'perl') {
      this.handlerCommand = 'dredd-hooks-perl';
      if (!which.which(this.handlerCommand)) {
        msg = " Perl hooks handler server command not found: " + this.handlerCommand + "\nInstall perl hooks handler by running:\n$ cpanm Dredd::Hooks";
        error = new Error(msg);
        return callback(error);
      } else {
        return callback();
      }
    } else if (this.language === 'nodejs') {
      msg = ' Hooks handler should not be used for nodejs. Use Dredds\' native node hooks instead.';
      error = new Error(msg);
      return callback(error);
    } else {
      this.handlerCommand = this.language;
      if (!which.which(this.handlerCommand)) {
        msg = "Hooks handler server command not found: " + this.handlerCommand;
        error = new Error(msg);
        return callback(error);
      } else {
        return callback();
      }
    }
  };

  HooksWorkerClient.prototype.spawnHandler = function(callback) {
    var pathGlobs, ref, ref1, ref2;
    pathGlobs = [].concat((ref = this.runner.hooks) != null ? (ref1 = ref.configuration) != null ? (ref2 = ref1.options) != null ? ref2.hookfiles : void 0 : void 0 : void 0);
    this.handler = child_process.spawn(this.handlerCommand, pathGlobs);
    logger.info("Spawning `" + this.language + "` hooks handler");
    this.handler.stdout.on('data', function(data) {
      return logger.info("Hook handler stdout:", data.toString());
    });
    this.handler.stderr.on('data', function(data) {
      return logger.info("Hook handler stderr:", data.toString());
    });
    this.handler.on('exit', (function(_this) {
      return function(status) {
        var error, msg;
        if (status != null) {
          if (status !== 0) {
            msg = "Hook handler '" + _this.handlerCommand + "' exited with status: " + status;
            logger.error(msg);
            error = new Error(msg);
            _this.runner.hookHandlerError = error;
          }
        } else {
          if (!_this.handlerKilledIntentionally) {
            msg = "Hook handler '" + _this.handlerCommand + "' was killed";
            logger.error(msg);
            error = new Error(msg);
            _this.runner.hookHandlerError = error;
          }
        }
        return _this.handlerEnded = true;
      };
    })(this));
    this.handler.on('error', (function(_this) {
      return function(error) {
        return _this.runner.hookHandlerError = _this.handlerEnded = error;
      };
    })(this));
    return callback();
  };

  HooksWorkerClient.prototype.connectToHandler = function(callback) {
    var connectAndSetupClient, start, timeout, waitForConnect;
    start = Date.now();
    waitForConnect = (function(_this) {
      return function() {
        var error, msg, timeout;
        if ((Date.now() - start) < _this.connectTimeout) {
          clearTimeout(timeout);
          if (_this.connectError !== false) {
            msg = 'Error connecting to the hook handler. Is the handler running? Retrying...';
            logger.warn(msg);
            _this.connectError = false;
          }
          if (_this.clientConnected !== true) {
            connectAndSetupClient();
            return timeout = setTimeout(waitForConnect, _this.connectRetry);
          }
        } else {
          clearTimeout(timeout);
          if (!_this.clientConnected) {
            if (_this.handlerClient != null) {
              _this.handlerClient.destroy();
            }
            msg = ("Connect timeout " + (_this.connectTimeout / 1000) + "s to the handler ") + ("on " + _this.handlerHost + ":" + _this.handlerPort + " exceeded, try increasing the limit.");
            error = new Error(msg);
            return callback(error);
          }
        }
      };
    })(this);
    connectAndSetupClient = (function(_this) {
      return function() {
        var handlerBuffer;
        if (_this.runner.hookHandlerError != null) {
          return callback(_this.runner.hookHandlerError);
        }
        _this.handlerClient = net.connect({
          port: _this.handlerPort,
          host: _this.handlerHost
        });
        _this.handlerClient.on('connect', function() {
          logger.info("Connected to the hook handler, waiting " + (_this.afterConnectWait / 1000) + "s to start testing.");
          _this.clientConnected = true;
          clearTimeout(timeout);
          return setTimeout(callback, _this.afterConnectWait);
        });
        _this.handlerClient.on('close', function() {});
        _this.handlerClient.on('error', function(connectError) {
          return _this.connectError = connectError;
        });
        handlerBuffer = "";
        return _this.handlerClient.on('data', function(data) {
          var i, j, len, len1, message, messages, results, splittedData;
          handlerBuffer += data.toString();
          if (data.toString().indexOf(_this.handlerMessageDelimiter) > -1) {
            splittedData = handlerBuffer.split(_this.handlerMessageDelimiter);
            handlerBuffer = splittedData.pop();
            messages = [];
            for (i = 0, len = splittedData.length; i < len; i++) {
              message = splittedData[i];
              messages.push(JSON.parse(message));
            }
            results = [];
            for (j = 0, len1 = messages.length; j < len1; j++) {
              message = messages[j];
              if (message.uuid != null) {
                results.push(_this.emitter.emit(message.uuid, message));
              } else {
                results.push(logger.log('UUID not present in message: ', JSON.stringify(message, null, 2)));
              }
            }
            return results;
          }
        });
      };
    })(this);
    return timeout = setTimeout(waitForConnect, this.connectRetry);
  };

  HooksWorkerClient.prototype.registerHooks = function(callback) {
    var eachHookNames, eventName, fn, i, len;
    eachHookNames = ['beforeEach', 'beforeEachValidation', 'afterEach', 'beforeAll', 'afterAll'];
    fn = (function(_this) {
      return function(eventName) {
        return _this.runner.hooks[eventName](function(data, hookCallback) {
          var handleTimeout, message, messageHandler, timeout, uuid;
          uuid = generateUuid();
          message = {
            event: eventName,
            uuid: uuid,
            data: data
          };
          _this.handlerClient.write(JSON.stringify(message));
          _this.handlerClient.write(_this.handlerMessageDelimiter);
          messageHandler = function(receivedMessage) {
            var index, j, key, len1, ref, ref1, value;
            clearTimeout(timeout);
            if (eventName.indexOf("All") > -1) {
              ref = receivedMessage.data;
              for (index = j = 0, len1 = ref.length; j < len1; index = ++j) {
                value = ref[index];
                data[index] = value;
              }
            } else {
              ref1 = receivedMessage.data;
              for (key in ref1) {
                if (!hasProp.call(ref1, key)) continue;
                value = ref1[key];
                data[key] = value;
              }
            }
            return hookCallback();
          };
          handleTimeout = function() {
            logger.warn('Hook handling timed out.');
            if (eventName.indexOf("All") === -1) {
              data.fail = 'Hook timed out.';
            }
            _this.emitter.removeListener(uuid, messageHandler);
            return hookCallback();
          };
          timeout = setTimeout(handleTimeout, _this.timeout);
          return _this.emitter.on(uuid, messageHandler);
        });
      };
    })(this);
    for (i = 0, len = eachHookNames.length; i < len; i++) {
      eventName = eachHookNames[i];
      fn(eventName);
    }
    this.runner.hooks.afterAll((function(_this) {
      return function(transactions, hookCallback) {
        var index, j, len1, mod, ref;
        if (process.env['TEST_DREDD_HOOKS_HANDLER_ORDER'] === "true") {
          console.error('FOR TESTING ONLY');
          ref = transactions[0]['hooks_modifications'];
          for (index = j = 0, len1 = ref.length; j < len1; index = ++j) {
            mod = ref[index];
            console.error(index + " " + mod);
          }
          console.error('FOR TESTING ONLY');
        }
        return _this.stop(hookCallback);
      };
    })(this));
    return callback();
  };

  return HooksWorkerClient;

})();

module.exports = HooksWorkerClient;
