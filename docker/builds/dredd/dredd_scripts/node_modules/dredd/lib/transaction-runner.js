// Generated by CoffeeScript 1.10.0
var Pitboss, TransactionRunner, addHooks, async, chai, clone, flattenHeaders, gavel, http, https, logger, os, packageConfig, path, sandboxedLogLibraryPath, sortTransactions, url,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  hasProp = {}.hasOwnProperty;

http = require('http');

https = require('https');

url = require('url');

path = require('path');

os = require('os');

chai = require('chai');

gavel = require('gavel');

async = require('async');

clone = require('clone');

Pitboss = require('pitboss-ng').Pitboss;

flattenHeaders = require('./flatten-headers');

addHooks = require('./add-hooks');

sortTransactions = require('./sort-transactions');

packageConfig = require('./../package.json');

logger = require('./logger');

sandboxedLogLibraryPath = '../../../lib/hooks-log-sandboxed';

TransactionRunner = (function() {
  function TransactionRunner(configuration1) {
    this.configuration = configuration1;
    this.executeTransaction = bind(this.executeTransaction, this);
    this.configureTransaction = bind(this.configureTransaction, this);
    this.logs = [];
    this.hookStash = {};
    this.hookHandlerError = null;
  }

  TransactionRunner.prototype.config = function(config) {
    this.configuration = config;
    return this.multiBlueprint = Object.keys(this.configuration.data).length > 1;
  };

  TransactionRunner.prototype.run = function(transactions, callback) {
    transactions = this.configuration.options['sorted'] ? sortTransactions(transactions) : transactions;
    async.mapSeries(transactions, this.configureTransaction.bind(this), function(err, results) {
      return transactions = results;
    });
    return addHooks(this, transactions, (function(_this) {
      return function(addHooksError) {
        if (addHooksError) {
          return callback(addHooksError);
        }
        return _this.executeAllTransactions(transactions, _this.hooks, callback);
      };
    })(this));
  };

  TransactionRunner.prototype.executeAllTransactions = function(transactions, hooks, callback) {
    var i, len, transaction;
    if (hooks.transactions == null) {
      hooks.transactions = {};
      for (i = 0, len = transactions.length; i < len; i++) {
        transaction = transactions[i];
        hooks.transactions[transaction.name] = transaction;
      }
    }
    if (this.hookHandlerError != null) {
      return callback(this.hookHandlerError);
    }
    return this.runHooksForData(hooks.beforeAllHooks, transactions, true, (function(_this) {
      return function() {
        if (_this.hookHandlerError != null) {
          return callback(_this.hookHandlerError);
        }
        return async.timesSeries(transactions.length, function(transactionIndex, iterationCallback) {
          transaction = transactions[transactionIndex];
          return _this.runHooksForData(hooks.beforeEachHooks, transaction, false, function() {
            if (_this.hookHandlerError != null) {
              return iterationCallback(_this.hookHandlerError);
            }
            return _this.runHooksForData(hooks.beforeHooks[transaction.name], transaction, false, function() {
              if (_this.hookHandlerError != null) {
                return iterationCallback(_this.hookHandlerError);
              }
              return _this.executeTransaction(transaction, hooks, function() {
                if (_this.hookHandlerError != null) {
                  return iterationCallback(_this.hookHandlerError);
                }
                return _this.runHooksForData(hooks.afterEachHooks, transaction, false, function() {
                  if (_this.hookHandlerError != null) {
                    return iterationCallback(_this.hookHandlerError);
                  }
                  return _this.runHooksForData(hooks.afterHooks[transaction.name], transaction, false, function() {
                    if (_this.hookHandlerError != null) {
                      return iterationCallback(_this.hookHandlerError);
                    }
                    return _this.emitResult(transaction, iterationCallback);
                  });
                });
              });
            });
          });
        }, function(iterationError) {
          if (iterationError) {
            return callback(iterationError);
          }
          return _this.runHooksForData(hooks.afterAllHooks, transactions, true, function() {
            if (_this.hookHandlerError != null) {
              return callback(_this.hookHandlerError);
            }
            return callback();
          });
        });
      };
    })(this));
  };

  TransactionRunner.prototype.runHooksForData = function(hooks, data, legacy, callback) {
    var runHookWithData;
    if (legacy == null) {
      legacy = false;
    }
    if ((hooks != null) && Array.isArray(hooks)) {
      logger.debug('Running hooks...');
      runHookWithData = (function(_this) {
        return function(hookFnIndex, callback) {
          var base, base1, base2, base3, base4, error, error1, hookFn, key, message, ref, value;
          hookFn = hooks[hookFnIndex];
          try {
            if (legacy) {
              return _this.runLegacyHook(hookFn, data, function(err) {
                var error;
                if (err) {
                  error = new Error(err);
                  _this.emitError(data, error);
                }
                return callback();
              });
            } else {
              return _this.runHook(hookFn, data, function(err) {
                var error;
                if (err) {
                  error = new Error(err);
                  _this.emitError(data, error);
                }
                return callback();
              });
            }
          } catch (error1) {
            error = error1;
            if (error instanceof chai.AssertionError) {
              message = "Failed assertion in hooks: " + error.message;
              if (data['results'] == null) {
                data['results'] = {};
              }
              if ((base = data['results'])['general'] == null) {
                base['general'] = {};
              }
              if ((base1 = data['results']['general'])['results'] == null) {
                base1['results'] = [];
              }
              data['results']['general']['results'].push({
                severity: 'error',
                message: message
              });
              data['message'] = message;
              if (data['test'] == null) {
                data['test'] = {};
              }
              data['test']['status'] = 'fail';
              if ((base2 = data['test'])['results'] == null) {
                base2['results'] = {};
              }
              ref = data['results'];
              for (key in ref) {
                value = ref[key];
                if (key !== 'version') {
                  if ((base3 = data['test']['results'])[key] == null) {
                    base3[key] = {};
                  }
                  if ((base4 = data['test']['results'][key])['results'] == null) {
                    base4['results'] = [];
                  }
                  data['test']['results'][key]['results'] = data['test']['results'][key]['results'].concat(value);
                }
              }
              _this.configuration.emitter.emit('test fail', data.test);
            } else {
              _this.emitError(data, error);
            }
            return callback();
          }
        };
      })(this);
      return async.timesSeries(hooks.length, runHookWithData, function() {
        return callback();
      });
    } else {
      return callback();
    }
  };

  TransactionRunner.prototype.emitError = function(transaction, error) {
    var test;
    test = {
      status: '',
      title: transaction.id,
      message: transaction.name,
      origin: transaction.origin,
      startedAt: transaction.startedAt,
      request: transaction.request
    };
    if (error) {
      return this.configuration.emitter.emit('test error', error, test);
    }
  };

  TransactionRunner.prototype.sandboxedHookResultsHandler = function(err, data, results, callback) {
    var i, key, len, log, ref, ref1, value;
    if (results == null) {
      results = {};
    }
    if (err) {
      return callback(err);
    }
    ref = results.data || {};
    for (key in ref) {
      value = ref[key];
      data[key] = value;
    }
    this.hookStash = results.stash;
    if (this.logs == null) {
      this.logs = [];
    }
    ref1 = results.logs || [];
    for (i = 0, len = ref1.length; i < len; i++) {
      log = ref1[i];
      this.logs.push(log);
    }
    callback();
  };

  TransactionRunner.prototype.sandboxedWrappedCode = function(hookCode) {
    return "// run the hook\nvar log = _log.bind(null, _logs);\n\nvar _func = " + hookCode + ";\n_func(_data);\n\n// setup the return object\nvar output = {};\noutput[\"data\"] = _data;\noutput[\"stash\"] = stash;\noutput[\"logs\"] = _logs;\noutput;";
  };

  TransactionRunner.prototype.runSandboxedHookFromString = function(hookString, data, callback) {
    var sandbox, wrappedCode;
    wrappedCode = this.sandboxedWrappedCode(hookString);
    sandbox = new Pitboss(wrappedCode, {
      timeout: 500
    });
    return sandbox.run({
      context: {
        '_data': data,
        '_logs': [],
        'stash': this.hookStash
      },
      libraries: {
        '_log': sandboxedLogLibraryPath
      }
    }, (function(_this) {
      return function(err, result) {
        if (result == null) {
          result = {};
        }
        sandbox.kill();
        return _this.sandboxedHookResultsHandler(err, data, result, callback);
      };
    })(this));
  };

  TransactionRunner.prototype.runLegacyHook = function(hook, data, callback) {
    if (typeof hook === 'function') {
      if (hook.length === 1) {
        logger.warn("DEPRECATION WARNING!");
        logger.warn("You are using only one argument for the `beforeAll` or `afterAll` hook function.");
        logger.warn("One argument hook functions will be treated as synchronous in next major release.");
        logger.warn("To keep the async behaviour, just define hook function with two parameters. ");
        logger.warn("");
        logger.warn("Api of the hooks functions will be unified soon across all hook functions:");
        logger.warn(" - `beforeAll` and `afterAll` hooks will support sync API depending on number of arguments");
        logger.warn(" - API of callback all functions will be the same");
        logger.warn(" - First passed argument will be a `transactions` object");
        logger.warn(" - Second passed argument will be a optional callback function for async");
        logger.warn(" - `transactions` object in `hooks` module object will be removed");
        logger.warn(" - Manipulation of transactions will have to be performed on first function argument");
        hook(callback);
      } else if (hook.length === 2) {
        hook(data, function() {
          return callback();
        });
      }
    }
    if (typeof hook === 'string') {
      return this.runSandboxedHookFromString(hook, data, callback);
    }
  };

  TransactionRunner.prototype.runHook = function(hook, data, callback) {
    if (typeof hook === 'function') {
      if (hook.length === 1) {
        hook(data);
        callback();
      } else if (hook.length === 2) {
        hook(data, function() {
          return callback();
        });
      }
    }
    if (typeof hook === 'string') {
      return this.runSandboxedHookFromString(hook, data, callback);
    }
  };

  TransactionRunner.prototype.configureTransaction = function(transaction, callback) {
    var configuration, configuredTransaction, expected, flatHeaders, fullPath, header, headerKey, headerValue, i, id, len, origin, ref, request, response, splitIndex, system;
    configuration = this.configuration;
    origin = transaction['origin'];
    request = transaction['request'];
    response = transaction['response'];
    if (this.parsedUrl == null) {
      this.parsedUrl = url.parse(configuration['server']);
    }
    if (this.parsedUrl['path'] === "/") {
      fullPath = request['uri'];
    } else {
      fullPath = '/' + [this.parsedUrl['path'].replace(/^\/|\/$/g, ""), request['uri'].replace(/^\/|\/$/g, "")].join("/");
    }
    flatHeaders = flattenHeaders(request['headers']);
    if (!flatHeaders['User-Agent']) {
      system = os.type() + ' ' + os.release() + '; ' + os.arch();
      flatHeaders['User-Agent'] = "Dredd/" + packageConfig['version'] + " (" + system + ")";
    }
    if (configuration.options.header.length > 0) {
      ref = configuration.options.header;
      for (i = 0, len = ref.length; i < len; i++) {
        header = ref[i];
        splitIndex = header.indexOf(':');
        headerKey = header.substring(0, splitIndex);
        headerValue = header.substring(splitIndex + 1);
        flatHeaders[headerKey] = headerValue;
      }
    }
    request['headers'] = flatHeaders;
    id = request['method'] + ' ' + request['uri'];
    expected = {
      headers: flattenHeaders(response['headers']),
      body: response['body'],
      statusCode: response['status']
    };
    if (response['schema']) {
      expected['bodySchema'] = response['schema'];
    }
    if (!this.multiBlueprint) {
      transaction.name = transaction.name.replace(transaction.origin.apiName + " > ", "");
    }
    configuredTransaction = {
      name: transaction.name,
      id: id,
      host: this.parsedUrl['hostname'],
      port: this.parsedUrl['port'],
      request: request,
      expected: expected,
      origin: origin,
      fullPath: fullPath,
      protocol: this.parsedUrl.protocol,
      skip: false
    };
    return callback(null, configuredTransaction);
  };

  TransactionRunner.prototype.emitResult = function(transaction, callback) {
    var base, base1, base2, base3, base4, key, message, ref, value;
    if (transaction.test) {
      if (transaction.test.valid === true) {
        if (transaction.fail) {
          transaction.test.status = 'fail';
          message = "Failed in after hook: " + transaction.fail;
          transaction.test.message = message;
          if (transaction['results'] == null) {
            transaction['results'] = {};
          }
          if ((base = transaction['results'])['general'] == null) {
            base['general'] = [];
          }
          if ((base1 = transaction['results']['general'])['results'] == null) {
            base1['results'] = [];
          }
          transaction['results']['general']['results'].push({
            severity: 'error',
            message: message
          });
          if (transaction['test'] == null) {
            transaction['test'] = {};
          }
          if ((base2 = transaction['test'])['results'] == null) {
            base2['results'] = {};
          }
          ref = transaction['results'];
          for (key in ref) {
            value = ref[key];
            if (key !== 'version') {
              if ((base3 = transaction['test']['results'])[key] == null) {
                base3[key] = {};
              }
              if ((base4 = transaction['test']['results'][key])['results'] == null) {
                base4['results'] = [];
              }
              transaction['test']['results'][key]['results'] = transaction['test']['results'][key]['results'].concat(value);
            }
          }
          this.configuration.emitter.emit('test fail', transaction.test, function() {});
        } else {
          this.configuration.emitter.emit('test pass', transaction.test, function() {});
        }
      }
    }
    return callback();
  };

  TransactionRunner.prototype.getRequestOptionsFromTransaction = function(transaction) {
    var requestOptions;
    requestOptions = {
      host: transaction.host,
      port: transaction.port,
      path: transaction.fullPath,
      method: transaction.request['method'],
      headers: transaction.request.headers
    };
    return requestOptions;
  };

  TransactionRunner.prototype.setContentLength = function(transaction) {
    var caseInsensitiveRequestHeadersMap, key, ref, value;
    caseInsensitiveRequestHeadersMap = {};
    ref = transaction.request.headers;
    for (key in ref) {
      value = ref[key];
      caseInsensitiveRequestHeadersMap[key.toLowerCase()] = key;
    }
    if (!caseInsensitiveRequestHeadersMap['content-length'] && transaction.request['body'] !== '') {
      return transaction.request.headers['Content-Length'] = Buffer.byteLength(transaction.request['body'], 'utf8');
    }
  };

  TransactionRunner.prototype.executeTransaction = function(transaction, hooks, callback) {
    var base, base1, message, ref, ref1, test;
    if (!callback) {
      callback = hooks;
      hooks = null;
    }
    this.setContentLength(transaction);
    transaction.startedAt = Date.now();
    test = {
      status: '',
      title: transaction.id,
      message: transaction.name,
      origin: transaction.origin,
      startedAt: transaction.startedAt
    };
    this.configuration.emitter.emit('test start', test, function() {});
    if (transaction['results'] == null) {
      transaction['results'] = {};
    }
    if ((base = transaction['results'])['general'] == null) {
      base['general'] = {};
    }
    if ((base1 = transaction['results']['general'])['results'] == null) {
      base1['results'] = [];
    }
    if (transaction.skip) {
      message = "Skipped in before hook";
      transaction['results']['general']['results'].push({
        severity: "warning",
        message: message
      });
      test['results'] = transaction['results'];
      test['status'] = 'skip';
      this.configuration.emitter.emit('test skip', test, function() {});
      return callback();
    } else if (transaction.fail) {
      message = "Failed in before hook: " + transaction.fail;
      transaction['results']['general']['results'].push({
        severity: 'error',
        message: message
      });
      test['message'] = message;
      test['status'] = 'fail';
      test['results'] = transaction['results'];
      this.configuration.emitter.emit('test fail', test, function() {});
      return callback();
    } else if (this.configuration.options['dry-run']) {
      logger.info("Dry run, skipping API Tests...");
      transaction.skip = true;
      return callback();
    } else if (this.configuration.options.names) {
      logger.info(transaction.name);
      transaction.skip = true;
      return callback();
    } else if (this.configuration.options.method.length > 0 && !(ref = transaction.request.method, indexOf.call(this.configuration.options.method, ref) >= 0)) {
      this.configuration.emitter.emit('test skip', test, function() {});
      transaction.skip = true;
      return callback();
    } else if (this.configuration.options.only.length > 0 && !(ref1 = transaction.name, indexOf.call(this.configuration.options.only, ref1) >= 0)) {
      this.configuration.emitter.emit('test skip', test, function() {});
      transaction.skip = true;
      return callback();
    } else {
      return this.performRequestAndValidate(test, transaction, hooks, callback);
    }
  };

  TransactionRunner.prototype.performRequestAndValidate = function(test, transaction, hooks, callback) {
    var buffer, error, error1, handleRequest, req, requestOptions, transport;
    requestOptions = this.getRequestOptionsFromTransaction(transaction);
    buffer = "";
    handleRequest = (function(_this) {
      return function(res) {
        res.on('data', function(chunk) {
          return buffer += chunk;
        });
        res.on('error', function(error) {
          if (error) {
            test.title = transaction.id;
            test.expected = transaction.expected;
            test.request = transaction.request;
            _this.configuration.emitter.emit('test error', error, test, function() {});
          }
          return callback();
        });
        return res.once('end', function() {
          var real;
          real = {
            statusCode: res.statusCode,
            headers: res.headers,
            body: buffer
          };
          transaction['real'] = real;
          return _this.runHooksForData(hooks != null ? hooks.beforeEachValidationHooks : void 0, transaction, false, function() {
            if (_this.hookHandlerError != null) {
              return callback(_this.hookHandlerError);
            }
            return _this.runHooksForData(hooks != null ? hooks.beforeValidationHooks[transaction.name] : void 0, transaction, false, function() {
              if (_this.hookHandlerError != null) {
                return callback(_this.hookHandlerError);
              }
              return _this.validateTransaction(test, transaction, callback);
            });
          });
        });
      };
    })(this);
    transport = transaction.protocol === 'https:' ? https : http;
    if (transaction.request['body'] && this.isMultipart(requestOptions)) {
      this.replaceLineFeedInBody(transaction, requestOptions);
    }
    try {
      req = transport.request(requestOptions, handleRequest);
      req.on('error', (function(_this) {
        return function(error) {
          test.title = transaction.id;
          test.expected = transaction.expected;
          test.request = transaction.request;
          _this.configuration.emitter.emit('test error', error, test, function() {});
          return callback();
        };
      })(this));
      if (transaction.request['body'] !== '') {
        req.write(transaction.request['body']);
      }
      return req.end();
    } catch (error1) {
      error = error1;
      test.title = transaction.id;
      test.expected = transaction.expected;
      test.request = transaction.request;
      this.configuration.emitter.emit('test error', error, test, function() {});
      return callback();
    }
  };

  TransactionRunner.prototype.validateTransaction = function(test, transaction, callback) {
    var configuration;
    configuration = this.configuration;
    return gavel.isValid(transaction.real, transaction.expected, 'response', function(isValidError, isValid) {
      if (isValidError) {
        configuration.emitter.emit('test error', isValidError, test, function() {});
      }
      test.start = test.start;
      test.title = transaction.id;
      test.actual = transaction.real;
      test.expected = transaction.expected;
      test.request = transaction.request;
      if (isValid) {
        test.status = "pass";
      } else {
        test.status = "fail";
      }
      return gavel.validate(transaction.real, transaction.expected, 'response', function(validateError, gavelResult) {
        var beforeResults, data, entityResult, i, key, len, message, ref, ref1, ref2, ref3, resultKey, value;
        if (!isValidError && validateError) {
          configuration.emitter.emit('test error', validateError, test, function() {});
        }
        message = '';
        ref = gavelResult || {};
        for (resultKey in ref) {
          if (!hasProp.call(ref, resultKey)) continue;
          data = ref[resultKey];
          if (resultKey !== 'version') {
            ref1 = data['results'] || [];
            for (i = 0, len = ref1.length; i < len; i++) {
              entityResult = ref1[i];
              message += resultKey + ": " + entityResult['message'] + "\n";
            }
          }
        }
        test['message'] = message;
        if (transaction['results'] == null) {
          transaction['results'] = {};
        }
        ref2 = gavelResult || {};
        for (key in ref2) {
          if (!hasProp.call(ref2, key)) continue;
          value = ref2[key];
          beforeResults = null;
          if (((ref3 = transaction['results'][key]) != null ? ref3['results'] : void 0) != null) {
            beforeResults = clone(transaction['results'][key]['results']);
          }
          transaction['results'][key] = value;
          if (beforeResults != null) {
            transaction['results'][key]['results'] = transaction['results'][key]['results'].concat(beforeResults);
          }
        }
        test['results'] = transaction['results'];
        test['valid'] = isValid;
        transaction['test'] = test;
        if (test['valid'] === false) {
          configuration.emitter.emit('test fail', test, function() {});
        }
        return callback();
      });
    });
  };

  TransactionRunner.prototype.isMultipart = function(requestOptions) {
    var caseInsensitiveRequestHeaders, key, ref, ref1, value;
    caseInsensitiveRequestHeaders = {};
    ref = requestOptions.headers;
    for (key in ref) {
      value = ref[key];
      caseInsensitiveRequestHeaders[key.toLowerCase()] = value;
    }
    return ((ref1 = caseInsensitiveRequestHeaders['content-type']) != null ? ref1.indexOf("multipart") : void 0) > -1;
  };

  TransactionRunner.prototype.replaceLineFeedInBody = function(transaction, requestOptions) {
    if (transaction.request['body'].indexOf('\r\n') === -1) {
      transaction.request['body'] = transaction.request['body'].replace(/\n/g, '\r\n');
      transaction.request['headers']['Content-Length'] = Buffer.byteLength(transaction.request['body'], 'utf8');
      return requestOptions.headers = transaction.request['headers'];
    }
  };

  return TransactionRunner;

})();

module.exports = TransactionRunner;
